{\rtf1\ansi\ansicpg1252\cocoartf2709
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Italic;\f1\fnil\fcharset0 Menlo-Regular;\f2\fnil\fcharset0 Menlo-Bold;
\f3\fswiss\fcharset0 Helvetica;\f4\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;\red154\green154\blue154;\red242\green242\blue242;\red38\green38\blue38;
\red100\green100\blue100;\red59\green81\blue185;\red137\green74\blue30;\red152\green37\blue37;\red55\green124\blue30;
\red0\green0\blue0;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c66667\c66667\c66667;\cssrgb\c96078\c96078\c96078;\cssrgb\c20000\c20000\c20000;
\cssrgb\c46667\c46667\c46667;\cssrgb\c29412\c41176\c77647;\cssrgb\c61176\c36471\c15294;\cssrgb\c66667\c21569\c19216;\cssrgb\c26667\c54902\c15294;
\cssrgb\c0\c0\c0;\csgray\c0;}
\margl1440\margr1440\vieww14480\viewh11600\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\i\fs24 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 -- EXPLAIN QUERY PLAN Output for Q1
\f1\i0 \cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 sqlite\cf5 \strokec5 >\cf4 \strokec4  EXPLAIN QUERY PLAN\cb1 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6 SELECT\cf4 \strokec4  \cf7 \strokec7 S\cf4 \strokec4 .\cf7 \strokec7 state_name\cf4 \strokec4 , \cf7 \strokec7 C\cf4 \strokec4 .\cf7 \strokec7 county_name\cf4 \strokec4 , \cf7 \strokec7 A\cf4 \strokec4 .\cf7 \strokec7 parameter_name\cf4 \strokec4 , 
\f2\b \cf8 \strokec8 AVG
\f1\b0 \cf4 \strokec4 (\cf7 \strokec7 A\cf4 \strokec4 .\cf7 \strokec7 aqi\cf4 \strokec4 ) \cf6 \strokec6 as\cf4 \strokec4  avg_aqi\cb1 \
\cf6 \cb3 \strokec6 FROM\cf4 \strokec4  AQI_Record A\cb1 \
\cf6 \cb3 \strokec6 JOIN\cf4 \strokec4  \cf6 \strokec6 State\cf4 \strokec4  S \cf6 \strokec6 ON\cf4 \strokec4  \cf7 \strokec7 A\cf4 \strokec4 .\cf7 \strokec7 state_code\cf4 \strokec4  \cf5 \strokec5 =\cf4 \strokec4  \cf7 \strokec7 S\cf4 \strokec4 .\cf7 \strokec7 state_code\cf4 \cb1 \strokec4 \
\cf6 \cb3 \strokec6 JOIN\cf4 \strokec4  County C \cf6 \strokec6 ON\cf4 \strokec4  \cf7 \strokec7 A\cf4 \strokec4 .\cf7 \strokec7 county_code\cf4 \strokec4  \cf5 \strokec5 =\cf4 \strokec4  \cf7 \strokec7 C\cf4 \strokec4 .\cf7 \strokec7 county_code\cf4 \strokec4  \cf6 \strokec6 AND\cf4 \strokec4  \cf7 \strokec7 A\cf4 \strokec4 .\cf7 \strokec7 state_code\cf4 \strokec4  \cf5 \strokec5 =\cf4 \strokec4  \cf7 \strokec7 C\cf4 \strokec4 .\cf7 \strokec7 state_code\cf4 \cb1 \strokec4 \
\cf6 \cb3 \strokec6 GROUP BY\cf4 \strokec4  \cf7 \strokec7 S\cf4 \strokec4 .\cf7 \strokec7 state_name\cf4 \strokec4 , \cf7 \strokec7 C\cf4 \strokec4 .\cf7 \strokec7 county_name\cf4 \strokec4 , \cf7 \strokec7 A\cf4 \strokec4 .\cf7 \strokec7 parameter_name\cf4 \cb1 \strokec4 \
\cf6 \cb3 \strokec6 HAVING\cf4 \strokec4  
\f2\b \cf8 \strokec8 AVG
\f1\b0 \cf4 \strokec4 (\cf7 \strokec7 A\cf4 \strokec4 .\cf7 \strokec7 aqi\cf4 \strokec4 ) \cf5 \strokec5 >\cf4 \strokec4  (\cb1 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3     \cf6 \strokec6 SELECT\cf4 \strokec4  
\f2\b \cf8 \strokec8 AVG
\f1\b0 \cf4 \strokec4 (aqi) \cf6 \strokec6 FROM\cf4 \strokec4  AQI_Record\cb1 \
\cb3 )\cb1 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6 ORDER BY\cf4 \strokec4  \cf7 \strokec7 S\cf4 \strokec4 .\cf7 \strokec7 state_name\cf4 \strokec4 , \cf7 \strokec7 C\cf4 \strokec4 .\cf7 \strokec7 county_name\cf4 \strokec4 ;\cb1 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 QUERY PLAN\cb1 \
\cb3 |
\f0\i \cf2 \strokec2 --SCAN A
\f1\i0 \cf4 \cb1 \strokec4 \
\cb3 |
\f0\i \cf2 \strokec2 --SEARCH S USING INTEGER PRIMARY KEY (rowid=?)
\f1\i0 \cf4 \cb1 \strokec4 \
\cb3 |
\f0\i \cf2 \strokec2 --SEARCH C USING INDEX sqlite_autoindex_County_1 (county_code=? AND state_code=?)
\f1\i0 \cf4 \cb1 \strokec4 \
\cb3 |
\f0\i \cf2 \strokec2 --USE TEMP B-TREE FOR GROUP BY
\f1\i0 \cf4 \cb1 \strokec4 \
\cb3 |
\f0\i \cf2 \strokec2 --SCALAR SUBQUERY 1
\f1\i0 \cf4 \cb1 \strokec4 \
\cb3 |  \cf5 \strokec5 `\cf9 \strokec9 --SCAN AQI_Record\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 `
\f0\i \cf2 \strokec2 --USE TEMP B-TREE FOR ORDER BY
\f1\i0 \cf4 \cb1 \strokec4 \
\
\
Before Optimization for Query 1: \
\pard\pardeftab720\sa240\partightenfactor0

\f3 \cf0 \strokec10 Before indexing, the query plan reveals several performance concerns. The most significant is that AQI_Record is subject to a full table scan, meaning SQLite reads every row in the table to process the query. This is compounded by the correlated subquery in the HAVING clause, which triggers a second full scan of AQI_Record to compute the global average AQI \'97 meaning the largest table in the database is scanned twice per query execution. Additionally, SQLite was unable to resolve the GROUP BY or ORDER BY clauses from an index, so it constructed temporary B-tree structures in memory to handle sorting, adding extra CPU and memory overhead.\
On the positive side, joins to the State and County tables were handled efficiently. State lookups used the integer primary key directly, and County lookups used an auto-generated index on its composite primary key, both of which are optimal.\
Overall, the primary bottlenecks before indexing are the repeated full scans of AQI_Record and the reliance on temporary structures for grouping and ordering.\
\
\pard\pardeftab720\partightenfactor0

\f1 \cf4 \outl0\strokewidth0 After Optimization for Query 1: 
\f3 \cf0 \outl0\strokewidth0 \strokec10 \
\pard\pardeftab720\sa240\partightenfactor0
\cf0 After applying indexes, the query plan shows meaningful performance improvements in the two most costly areas identified before indexing. The full table scan on AQI_Record is now replaced by a scan using the covering index 
\fs26 idx_aqi_composite
\fs24 , meaning SQLite can resolve the join, grouping, and AQI values entirely from the index without touching the main table. Similarly, the subquery that computes the global average AQI now uses the covering index 
\fs26 idx_aqi_aqi
\fs24 , avoiding a second full table scan on the raw data. In both cases, SQLite no longer needs to fetch rows from the table itself, which reduces I/O significantly.\
The joins to State and County remain optimal, unchanged from before. The temporary B-tree structures for GROUP BY and ORDER BY are still present, which is expected \'97 these are difficult to eliminate without restructuring the query itself, and their overhead is minor compared to the full table scans that were resolved.\
Overall, the indexes successfully addressed the two primary bottlenecks identified before indexing, and the query plan is meaningfully more efficient as a result.
\f4 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f1\fs22 \cf11 \kerning1\expnd0\expndtw0 \CocoaLigature0 \outl0\strokewidth0 QUERY PLAN\
|--SCAN A USING COVERING INDEX idx_aqi_composite\
|--SEARCH S USING INTEGER PRIMARY KEY (rowid=?)\
|--SEARCH C USING INDEX sqlite_autoindex_County_1 (county_code=? AND state_code=?)\
|--USE TEMP B-TREE FOR GROUP BY\
|--SCALAR SUBQUERY 1\
|  `--SCAN AQI_Record USING COVERING INDEX idx_aqi_aqi\
`--USE TEMP B-TREE FOR ORDER BY
\f4\fs24 \cf0 \expnd0\expndtw0\kerning0
\CocoaLigature1 \outl0\strokewidth0 \strokec10 \
\pard\pardeftab720\sa240\partightenfactor0
\cf0 \strokec10 \
}